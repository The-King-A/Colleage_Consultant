# 高考志愿填报助手系统 - 详细设计文档

**项目名称**: 智能高考志愿填报咨询系统（Consultant）  
**版本**: v1.0.0  
**创建日期**: 2025年10月7日  
**作者**: 传智教育开发团队  
**文档类型**: 系统设计文档

---

## 目录

1. [项目概述](#1-项目概述)
2. [系统架构](#2-系统架构)
3. [技术栈](#3-技术栈)
4. [核心功能模块](#4-核心功能模块)
5. [后端架构设计](#5-后端架构设计)
6. [前端架构设计](#6-前端架构设计)
7. [数据库设计](#7-数据库设计)
8. [API接口设计](#8-api接口设计)
9. [数据流程](#9-数据流程)
10. [核心技术实现](#10-核心技术实现)
11. [安全设计](#11-安全设计)
12. [性能优化](#12-性能优化)
13. [部署架构](#13-部署架构)
14. [开发规范](#14-开发规范)
15. [未来扩展](#15-未来扩展)

---

## 1. 项目概述

### 1.1 项目背景

高考志愿填报是关系考生未来发展的重要决策，但传统的志愿填报存在以下痛点：
- 信息量大，考生和家长难以全面了解所有院校和专业
- 缺乏专业指导，容易盲目填报
- 录取数据分散，难以进行科学分析
- 人工咨询成本高，服务覆盖面有限

### 1.2 解决方案

本系统基于AI大语言模型和RAG（检索增强生成）技术，提供智能化的志愿填报咨询服务：
- **智能问答**：7×24小时AI顾问，解答院校、专业相关问题
- **志愿推荐**：基于分数和意向，智能推荐院校和专业（冲稳保策略）
- **兴趣测试**：多维度评估学生特质，推荐适合的专业方向
- **预约咨询**：支持一对一人工专家指导预约

### 1.3 核心价值

- **智能化**：基于通义千问大模型，理解自然语言，提供精准答案
- **个性化**：结合考生分数、兴趣、地域等因素，量身定制方案
- **实时性**：流式响应，打字机效果，提升用户体验
- **专业性**：基于历年真实录取数据和院校资料
- **易用性**：现代化UI设计，操作简单直观

---

## 2. 系统架构

### 2.1 整体架构图

```
┌─────────────────────────────────────────────────────────────┐
│                        用户层（Browser）                      │
│   ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐   │
│   │  首页    │  │智能问答  │  │志愿推荐  │  │兴趣测试  │   │
│   └──────────┘  └──────────┘  └──────────┘  └──────────┘   │
└───────────────────────────┬─────────────────────────────────┘
                            │ HTTP/WebSocket
┌───────────────────────────┴─────────────────────────────────┐
│                    前端层（Vue 3 + Vite）                     │
│  ┌────────────┐  ┌────────────┐  ┌────────────┐            │
│  │ Vue Router │  │   Pinia    │  │ Element+   │            │
│  │  路由管理   │  │  状态管理   │  │  UI组件    │            │
│  └────────────┘  └────────────┘  └────────────┘            │
│  ┌────────────────────────────────────────────┐            │
│  │         API Service（axios + fetch）        │            │
│  │  - chatStream (流式对话)                    │            │
│  │  - interestTestStream (兴趣测试)            │            │
│  └────────────────────────────────────────────┘            │
└───────────────────────────┬─────────────────────────────────┘
                            │ RESTful API
┌───────────────────────────┴─────────────────────────────────┐
│               后端层（Spring Boot + LangChain4j）             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │               ChatController (控制器)                │   │
│  │  - GET /chat (智能问答)                              │   │
│  │  - GET /interest-test (兴趣测试)                     │   │
│  └────────────────────┬────────────────────────────────┘   │
│                       │                                      │
│  ┌────────────────────┴────────────────────────────────┐   │
│  │            AI Service（服务层）                       │   │
│  │  ┌─────────────────┐  ┌─────────────────────┐      │   │
│  │  │ConsultantService│  │InterestTestService  │      │   │
│  │  │  (志愿咨询)      │  │  (兴趣测试)          │      │   │
│  │  └─────────────────┘  └─────────────────────┘      │   │
│  └────────────────────┬────────────────────────────────┘   │
│                       │                                      │
│  ┌────────────────────┴────────────────────────────────┐   │
│  │              CommonConfig (配置层)                    │   │
│  │  - ChatMemoryProvider (会话记忆提供者)               │   │
│  │  - ContentRetriever (向量检索器)                     │   │
│  │  - EmbeddingStore (向量存储初始化)                   │   │
│  └─────────────────────────────────────────────────────┘   │
└───────────────────────────┬─────────────────────────────────┘
                            │
┌───────────────────────────┴─────────────────────────────────┐
│                      AI & 数据层                              │
│  ┌──────────────┐  ┌──────────────┐  ┌─────────────────┐   │
│  │ 通义千问API  │  │  Redis Store │  │ PDF文档知识库   │   │
│  │              │  │              │  │                 │   │
│  │ - Chat Model │  │ - 会话记忆   │  │ - 院校简介      │   │
│  │ - Streaming  │  │ - 向量存储   │  │ - 录取规则      │   │
│  │ - Embedding  │  │              │  │ - 专业信息      │   │
│  └──────────────┘  └──────────────┘  └─────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 架构特点

**分层架构**
- **表现层**：Vue 3组件化开发，职责清晰
- **业务层**：Spring Boot服务层，处理业务逻辑
- **数据层**：Redis缓存 + 向量数据库

**前后端分离**
- 前端独立部署，使用Vite构建
- 后端RESTful API，支持跨域
- 通过代理或CORS实现通信

**微服务思想**
- AI服务通过接口定义，便于扩展
- 不同功能模块独立服务（ConsultantService、InterestTestService）
- 易于水平扩展和服务治理

---

## 3. 技术栈

### 3.1 后端技术栈

| 技术 | 版本 | 用途 | 说明 |
|------|------|------|------|
| **Java** | 17 | 开发语言 | LTS版本，稳定可靠 |
| **Spring Boot** | 3.5.4 | Web框架 | 最新稳定版，简化配置 |
| **LangChain4j** | 1.0.1-beta6 | AI集成框架 | Java版LangChain，简化AI应用开发 |
| **通义千问** | qwen-plus | 大语言模型 | 阿里云AI模型，中文理解能力强 |
| **Redis** | 7.x | 数据存储 | 会话记忆 + 向量存储 |
| **Apache PDFBox** | - | 文档解析 | PDF文档解析和文本提取 |
| **Spring WebFlux** | 3.5.4 | 响应式Web | 支持流式响应 |
| **Maven** | 3.6+ | 构建工具 | 依赖管理和项目构建 |

**核心依赖**：
```xml
<!-- LangChain4j核心 -->
<dependency>
    <groupId>dev.langchain4j</groupId>
    <artifactId>langchain4j-spring-boot-starter</artifactId>
    <version>1.0.1-beta6</version>
</dependency>

<!-- OpenAI兼容模型支持 -->
<dependency>
    <groupId>dev.langchain4j</groupId>
    <artifactId>langchain4j-open-ai-spring-boot-starter</artifactId>
    <version>1.0.1-beta6</version>
</dependency>

<!-- Redis向量数据库 -->
<dependency>
    <groupId>dev.langchain4j</groupId>
    <artifactId>langchain4j-community-redis-spring-boot-starter</artifactId>
    <version>1.0.1-beta6</version>
</dependency>

<!-- Easy RAG支持 -->
<dependency>
    <groupId>dev.langchain4j</groupId>
    <artifactId>langchain4j-easy-rag</artifactId>
    <version>1.0.1-beta6</version>
</dependency>
```

### 3.2 前端技术栈

| 技术 | 版本 | 用途 | 说明 |
|------|------|------|------|
| **Vue.js** | 3.5.22 | 前端框架 | Composition API，性能优异 |
| **Vite** | 7.1.7 | 构建工具 | 快速开发，热更新 |
| **Vue Router** | 4.2.5 | 路由管理 | 单页应用导航 |
| **Pinia** | 2.1.7 | 状态管理 | Vue 3官方推荐 |
| **Element Plus** | 2.5.4 | UI组件库 | 企业级组件库 |
| **Axios** | 1.6.5 | HTTP客户端 | Promise API请求 |
| **Fetch API** | 原生 | 流式请求 | 支持ReadableStream |

**核心依赖**：
```json
{
  "dependencies": {
    "vue": "^3.5.22",
    "vue-router": "^4.2.5",
    "pinia": "^2.1.7",
    "element-plus": "^2.5.4",
    "@element-plus/icons-vue": "^2.3.1",
    "axios": "^1.6.5"
  }
}
```

### 3.3 开发工具

- **IDE**: IntelliJ IDEA / VS Code
- **版本控制**: Git
- **API测试**: Postman / Apifox
- **数据库客户端**: RedisInsight
- **包管理**: Maven (后端) / npm (前端)

---

## 4. 核心功能模块

### 4.1 功能模块总览

```
智能高考志愿填报系统
├── 智能问答模块
│   ├── 院校信息查询
│   ├── 专业信息查询
│   ├── 录取分数查询
│   ├── 热门/天坑专业查询
│   └── 预约咨询服务
├── 志愿推荐模块
│   ├── 考生信息采集
│   ├── 智能匹配算法
│   ├── 冲稳保策略
│   └── 推荐结果展示
├── 兴趣测试模块
│   ├── 多维度问卷测试
│   ├── 性格/兴趣分析
│   ├── 专业匹配推荐
│   └── 测试报告生成
└── 首页展示模块
    ├── 功能介绍
    ├── 服务统计
    └── 快速导航
```

### 4.2 智能问答模块

**功能描述**：
- 基于大模型的自然语言对话
- 支持多轮对话上下文记忆
- RAG检索增强，提供准确信息
- 流式响应，实时打字机效果

**支持的查询类型**：
1. 院校简介查询
2. 录取规则查询
3. 奖学金设置查询
4. 食宿条件查询
5. 招生联系方式查询
6. 历年录取分数查询
7. 热门专业查询
8. 天坑专业识别
9. 院校/专业推荐
10. 一对一咨询预约

**技术实现**：
- **AI服务**：ConsultantService接口
- **系统提示**：system.txt定义角色和能力
- **会话记忆**：Redis存储，支持24小时保持
- **向量检索**：从PDF知识库检索相关内容
- **流式输出**：WebFlux + Reactor实现

### 4.3 志愿推荐模块

**功能描述**：
- 表单化信息采集
- 基于AI的智能推荐
- 冲稳保梯度策略
- 包含历年分数和专业热度

**表单字段**：
- 考生姓名（必填）
- 考生性别（必填）
- 所在省份（31个省市，必填）
- 高考分数（0-750，必填）
- 科目类型（理科/文科/综合，必填）
- 意向专业方向（20+类别，可多选）
- 意向地区（7大地区，可多选）
- 其他要求（可选）

**推荐策略**：
```
冲：录取概率30-50%，比考生分数高10-30分的院校
稳：录取概率70-90%，与考生分数接近的院校
保：录取概率90%+，比考生分数低10-20分的院校
```

**输出内容**：
- 推荐院校列表（按匹配度排序）
- 推荐专业列表
- 历年录取分数对比
- 专业热度分析
- 填报建议

### 4.4 兴趣测试模块

**功能描述**：
- AI引导式对话测试
- 10个问题覆盖4个维度
- 自动生成详细报告
- 个性化专业推荐

**测试维度**：
1. **学科兴趣**（2-3问）
   - 最喜欢/不喜欢的学科
   - 擅长的学科领域
   - 课外学习兴趣

2. **职业兴趣**（2-3问）
   - 理想工作类型
   - 工作环境偏好
   - 职业规划想法

3. **性格特点**（2-3问）
   - 内向/外向
   - 逻辑/创造思维
   - 独立/团队偏好
   - 抗压能力

4. **价值观**（2-3问）
   - 稳定vs挑战
   - 收入vs兴趣
   - 社会贡献观
   - 个人成就定义

**报告结构**：
```markdown
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📊 一、综合特质画像
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
- 学科兴趣分析
- 职业兴趣倾向
- 性格特征分析
- 价值观与动机
- 综合评价

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 二、专业推荐（按匹配度排序）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
【🌟 强烈推荐】匹配度90%以上
1. 专业1
   - 专业介绍
   - 推荐理由
   - 职业发展方向
   - 推荐院校
   - 就业前景

【✨ 适合考虑】匹配度75-90%
【💭 可以尝试】匹配度60-75%

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📚 三、学习发展建议
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
- 当前优势强化
- 能力补充提升
- 推荐学习资源
- 高中阶段规划

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
💡 四、志愿填报建议
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
- 选专业策略
- 院校选择建议
- 注意事项
```

---

## 5. 后端架构设计

### 5.1 项目结构

```
Backend/
└── src/
    ├── main/
    │   ├── java/com/isoft/consultant/
    │   │   ├── ConsultantApplication.java    # 启动类
    │   │   ├── controller/                    # 控制器层
    │   │   │   └── ChatController.java        
    │   │   ├── aiservice/                     # AI服务层
    │   │   │   ├── ConsultantService.java    # 志愿咨询服务
    │   │   │   └── InterestTestService.java  # 兴趣测试服务
    │   │   ├── config/                        # 配置层
    │   │   │   ├── CommonConfig.java         # 核心配置
    │   │   │   └── CorsConfig.java           # 跨域配置
    │   │   └── repository/                    # 数据访问层
    │   │       └── RedisChatMemoryStore.java
    │   └── resources/
    │       ├── application.yaml               # 应用配置
    │       ├── system.txt                     # 志愿咨询提示词
    │       ├── system_interest_test.txt       # 兴趣测试提示词
    │       └── content/                       # 知识库PDF
    │           ├── 西安交通大学.pdf
    │           ├── 热门专业top20.pdf
    │           └── ...
    └── test/                                  # 测试代码
```

### 5.2 核心类设计

#### 5.2.1 ChatController（控制器）

**职责**：
- 接收HTTP请求
- 参数验证
- 调用AI服务
- 返回流式响应

**核心代码**：
```java
@RestController
public class ChatController {
    @Autowired
    private ConsultantService consultantService;
    
    @Autowired
    private InterestTestService interestTestService;

    @RequestMapping(value = "/chat", produces = "text/html;charset=utf-8")
    public Flux<String> chat(String memoryId, String message) {
        return consultantService.chat(memoryId, message);
    }

    @RequestMapping(value = "/interest-test", produces = "text/html;charset=utf-8")
    public Flux<String> interestTest(String memoryId, String message) {
        return interestTestService.chat(memoryId, message);
    }
}
```

**设计特点**：
- 返回`Flux<String>`实现流式响应
- `produces = "text/html;charset=utf-8"`支持中文
- RESTful风格，简洁易用

#### 5.2.2 ConsultantService（AI服务接口）

**职责**：
- 定义AI服务能力
- 集成LangChain4j
- 支持会话记忆和RAG检索

**核心代码**：
```java
@AiService(
    wiringMode = AiServiceWiringMode.EXPLICIT,
    chatModel = "openAiChatModel",
    streamingChatModel = "openAiStreamingChatModel",
    chatMemoryProvider = "chatMemoryProvider",
    contentRetriever = "contentRetriever"
)
public interface ConsultantService {
    @SystemMessage(fromResource = "system.txt")
    public Flux<String> chat(@MemoryId String memoryId, 
                              @UserMessage String message);
}
```

**设计特点**：
- `@AiService`注解自动生成实现类
- `@SystemMessage`从文件加载系统提示词
- `@MemoryId`标记会话ID，支持多轮对话
- `chatMemoryProvider`提供会话记忆
- `contentRetriever`提供RAG检索能力

#### 5.2.3 CommonConfig（配置类）

**职责**：
- 配置AI模型
- 配置会话记忆
- 配置向量数据库
- 初始化知识库

**核心Bean**：

1. **ChatMemoryProvider**：
```java
@Bean
public ChatMemoryProvider chatMemoryProvider() {
    return memoryId -> MessageWindowChatMemory.builder()
        .id(memoryId)
        .maxMessages(20)
        .chatMemoryStore(redisChatMemoryStore)
        .build();
}
```
- 为每个用户创建独立会话记忆
- 最多保留20条消息
- 存储在Redis中

2. **EmbeddingStore**：
```java
@Bean
public EmbeddingStore store() {
    // 1. 加载PDF文档
    List<Document> documents = ClassPathDocumentLoader
        .loadDocuments("content", new ApachePdfBoxDocumentParser());
    
    // 2. 文档分割（500字/块，100字重叠）
    DocumentSplitter splitter = DocumentSplitters.recursive(500, 100);
    
    // 3. 向量化并存储
    EmbeddingStoreIngestor ingestor = EmbeddingStoreIngestor.builder()
        .embeddingStore(redisEmbeddingStore)
        .documentSplitter(splitter)
        .embeddingModel(embeddingModel)
        .build();
    ingestor.ingest(documents);
    
    return redisEmbeddingStore;
}
```
- 启动时自动加载PDF知识库
- 切割成500字的文本块
- 使用text-embedding-v3模型向量化
- 存储到Redis向量数据库

3. **ContentRetriever**：
```java
@Bean
public ContentRetriever contentRetriever() {
    return EmbeddingStoreContentRetriever.builder()
        .embeddingStore(redisEmbeddingStore)
        .minScore(0.5)       // 最低相似度
        .maxResults(3)       // 最多返回3个结果
        .embeddingModel(embeddingModel)
        .build();
}
```
- 根据用户问题检索相关知识
- 相似度阈值0.5，过滤不相关内容
- 返回Top 3最相关的文本块

#### 5.2.4 RedisChatMemoryStore（Redis存储）

**职责**：
- 实现ChatMemoryStore接口
- 管理会话记忆的CRUD
- 支持24小时过期

**核心代码**：
```java
@Repository
public class RedisChatMemoryStore implements ChatMemoryStore {
    @Autowired
    private StringRedisTemplate redisTemplate;
    
    @Override
    public List<ChatMessage> getMessages(Object memoryId) {
        String json = redisTemplate.opsForValue().get(memoryId);
        return ChatMessageDeserializer.messagesFromJson(json);
    }
    
    @Override
    public void updateMessages(Object memoryId, List<ChatMessage> messages) {
        String json = ChatMessageSerializer.messagesToJson(messages);
        redisTemplate.opsForValue().set(
            memoryId.toString(), 
            json, 
            Duration.ofDays(1)
        );
    }
    
    @Override
    public void deleteMessages(Object memoryId) {
        redisTemplate.delete(memoryId.toString());
    }
}
```

**设计特点**：
- 使用JSON序列化存储消息
- 24小时自动过期
- 支持清空会话

### 5.3 配置文件设计

**application.yaml**：
```yaml
langchain4j:
  open-ai:
    chat-model:
      base-url: https://dashscope.aliyuncs.com/compatible-mode/v1
      api-key: ${API-KEY}
      model-name: qwen-plus
      log-requests: true
      log-responses: true
    streaming-chat-model:
      base-url: https://dashscope.aliyuncs.com/compatible-mode/v1
      api-key: ${API-KEY}
      model-name: qwen-plus
    embedding-model:
      base-url: https://dashscope.aliyuncs.com/compatible-mode/v1
      api-key: ${API-KEY}
      model-name: text-embedding-v3
      max-segments-per-batch: 10
  community:
    redis:
      host: localhost
      port: 6379

spring:
  data:
    redis:
      host: localhost
      port: 6379

logging:
  level:
    dev.langchain4j: debug
```

**配置说明**：
- 使用环境变量`${API-KEY}`保护密钥
- 通义千问兼容OpenAI接口
- 同时配置chat-model和streaming-chat-model
- embedding-model用于文本向量化
- Redis配置在两处，分别用于LangChain4j和Spring

---

## 6. 前端架构设计

### 6.1 项目结构

```
Front/Consultant/
├── public/
│   └── favicon.ico
├── src/
│   ├── api/                        # API接口层
│   │   └── chat.js                 # 聊天API
│   ├── assets/                     # 静态资源
│   │   ├── logo.svg
│   │   └── main.css
│   ├── components/                 # 公共组件
│   │   └── icons/                  # 图标组件
│   ├── router/                     # 路由配置
│   │   └── index.js
│   ├── stores/                     # 状态管理
│   │   └── chat.js                 # 聊天状态
│   ├── views/                      # 页面视图
│   │   ├── HomeView.vue            # 首页
│   │   ├── ChatView.vue            # 智能问答
│   │   ├── RecommendView.vue       # 志愿推荐
│   │   └── InterestTestView.vue    # 兴趣测试
│   ├── App.vue                     # 根组件
│   └── main.js                     # 入口文件
├── index.html
├── package.json
├── vite.config.js                  # Vite配置
└── eslint.config.js                # ESLint配置
```

### 6.2 核心组件设计

#### 6.2.1 App.vue（根组件）

**职责**：
- 应用根容器
- 导航栏
- 路由出口

**设计特点**：
- 全屏页面（如/chat）不显示导航
- 响应式布局
- 统一的品牌风格

#### 6.2.2 ChatView.vue（智能问答页面）

**核心功能**：
1. **欢迎界面**：
   - 服务介绍
   - 快速提问卡片
   - 温馨提示

2. **消息列表**：
   - 用户消息（右侧，蓝色气泡）
   - AI消息（左侧，白色气泡，左侧蓝条）
   - 打字光标效果
   - 自动滚动

3. **输入区**：
   - 输入框
   - 发送按钮
   - 禁用状态（加载中）

**关键代码片段**：

```javascript
// 流式接收消息
const handleSend = async () => {
  const assistantMessage = {
    role: 'assistant',
    content: '',
    time: getCurrentTime()
  }
  messages.value.push(assistantMessage)
  
  let fullContent = ''
  const messageIndex = messages.value.length - 1
  
  await chatStream(
    chatStore.memoryId,
    currentMessage,
    (chunk) => {
      fullContent += chunk
      messages.value[messageIndex].content = fullContent
      scrollToBottom()
    }
  )
}
```

**UI特色**：
- 打字机光标动画（闪烁效果）
- 消息淡入动画
- 平滑滚动
- 渐变背景

#### 6.2.3 RecommendView.vue（志愿推荐页面）

**布局**：
- 左侧：表单（考生信息采集）
- 右侧：结果展示

**表单验证**：
```javascript
const rules = {
  name: [
    { required: true, message: '请输入考生姓名', trigger: 'blur' }
  ],
  score: [
    { required: true, message: '请输入高考分数', trigger: 'blur' },
    { type: 'number', min: 0, max: 750, message: '分数范围应在0-750之间' }
  ]
}
```

**推荐逻辑**：
```javascript
const handleSubmit = async () => {
  await formRef.value.validate()
  
  const message = `
我是一名来自${formData.province}的考生，
高考成绩为${formData.score}分，
科目类型为${formData.subject}。
${formData.interestedMajors.length > 0 ? 
  `我对以下专业方向比较感兴趣：${formData.interestedMajors.join('、')}。` : ''}
请根据我的情况，按照"冲、稳、保"的策略推荐院校和专业。
  `.trim()
  
  await chatStream(chatStore.generateMemoryId(), message, (chunk) => {
    recommendResult.value += chunk
  })
}
```

**设计特点**：
- 使用新的memoryId，避免混淆
- 将表单数据转换为自然语言
- 实时流式展示结果
- 响应式两栏布局

### 6.3 状态管理（Pinia）

**chat.js**：
```javascript
import { defineStore } from 'pinia'
import { ref } from 'vue'

export const useChatStore = defineStore('chat', () => {
  const memoryId = ref(generateMemoryId())
  const chatHistory = ref([])

  function generateMemoryId() {
    return `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  }

  function resetChat() {
    memoryId.value = generateMemoryId()
    chatHistory.value = []
  }

  function addMessage(message) {
    chatHistory.value.push(message)
  }

  return {
    memoryId,
    chatHistory,
    generateMemoryId,
    resetChat,
    addMessage
  }
})
```

**设计特点**：
- Composition API风格
- 自动生成唯一memoryId
- 支持重置会话
- 可扩展消息历史管理

### 6.4 API服务层

**chat.js**：

**流式请求实现**：
```javascript
export const chatStream = async (memoryId, message, onMessage) => {
  const response = await fetch(
    `/api/chat?memoryId=${encodeURIComponent(memoryId)}&message=${encodeURIComponent(message)}`,
    {
      method: 'GET',
      headers: { 'Accept': 'text/html;charset=utf-8' }
    }
  )

  const reader = response.body.getReader()
  const decoder = new TextDecoder('utf-8')

  while (true) {
    const { done, value } = await reader.read()
    if (done) break

    const chunk = decoder.decode(value, { stream: true })
    
    // 逐字符输出，打字机效果
    for (let i = 0; i < chunk.length; i++) {
      onMessage(chunk[i])
      
      const char = chunk[i]
      let delay = 30
      
      if (/[\u4e00-\u9fa5]/.test(char)) delay = 40      // 中文
      else if (/[。！？\n]/.test(char)) delay = 100      // 句号停顿
      else if (/[，,]/.test(char)) delay = 60           // 逗号停顿
      else if (/[a-zA-Z\s]/.test(char)) delay = 20      // 英文
      
      await new Promise(resolve => setTimeout(resolve, delay))
    }
  }
}
```

**打字机效果设计**：
- 中文字符：40ms
- 英文字母：20ms
- 逗号：60ms停顿
- 句号/换行：100ms停顿
- 创造自然的阅读节奏

**错误处理**：
```javascript
if (!response.ok) {
  let errorMessage = '服务器错误'
  if (response.status === 500) {
    errorMessage = '后端服务器内部错误，请检查：\n1. Redis是否启动\n2. API Key是否配置\n3. 后端日志'
  } else if (response.status === 404) {
    errorMessage = '接口不存在，请确认后端服务已启动'
  } else if (response.status === 401) {
    errorMessage = 'API认证失败，请检查API Key配置'
  }
  throw new Error(errorMessage)
}
```

### 6.5 路由配置

**router/index.js**：
```javascript
import { createRouter, createWebHistory } from 'vue-router'

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes: [
    {
      path: '/',
      name: 'home',
      component: () => import('../views/HomeView.vue')
    },
    {
      path: '/chat',
      name: 'chat',
      component: () => import('../views/ChatView.vue')
    },
    {
      path: '/recommend',
      name: 'recommend',
      component: () => import('../views/RecommendView.vue')
    },
    {
      path: '/interest-test',
      name: 'interestTest',
      component: () => import('../views/InterestTestView.vue')
    }
  ]
})

export default router
```

**设计特点**：
- 懒加载路由组件
- HTML5 History模式
- 语义化路由命名

### 6.6 Vite配置

**vite.config.js**：
```javascript
export default defineConfig({
  plugins: [vue(), vueDevTools()],
  resolve: {
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url))
    }
  },
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:8080',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, '')
      }
    }
  }
})
```

**代理配置说明**：
- `/api/*` → `http://localhost:8080/*`
- 解决开发环境跨域问题
- 生产环境需要Nginx反向代理

---

## 7. 数据库设计

### 7.1 Redis数据结构

**会话记忆存储**：
```
Key: user_1728300000000_abc123 (memoryId)
Type: String
Value: JSON序列化的ChatMessage列表
TTL: 86400秒（24小时）

示例：
[
  {
    "type": "USER",
    "text": "介绍一下西安交通大学"
  },
  {
    "type": "AI",
    "text": "西安交通大学是中国著名的..."
  }
]
```

**向量数据库存储**：
```
Key前缀: langchain4j:embedding:*
Type: Hash
Fields:
  - id: 文档块ID
  - embedding: 向量（浮点数数组）
  - text: 原始文本
  - metadata: 元数据（文件名、页码等）

索引：
使用RediSearch创建向量索引
支持余弦相似度搜索
```

### 7.2 数据流转

**知识库初始化流程**：
```
1. 加载PDF文档
   ↓
2. 解析PDF文本
   ↓
3. 文档分块（500字/块，100字重叠）
   ↓
4. 调用text-embedding-v3向量化
   ↓
5. 存储到Redis向量数据库
   ↓
6. 创建向量索引
```

**会话记忆流程**：
```
用户发送消息
   ↓
根据memoryId从Redis加载历史
   ↓
拼接历史+当前消息
   ↓
调用大模型
   ↓
接收AI响应
   ↓
更新Redis会话记忆（24小时TTL）
```

---

## 8. API接口设计

### 8.1 接口清单

| 接口名称 | 方法 | 路径 | 功能 |
|---------|------|------|------|
| 智能问答 | GET | /chat | 志愿填报咨询 |
| 兴趣测试 | GET | /interest-test | 职业兴趣测试 |

### 8.2 接口详情

#### 8.2.1 智能问答接口

**请求**：
```http
GET /chat?memoryId=user_1728300000000_abc123&message=介绍一下西安交通大学 HTTP/1.1
Accept: text/html;charset=utf-8
```

**参数**：
| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| memoryId | String | 是 | 会话ID，用于上下文记忆 |
| message | String | 是 | 用户消息 |

**响应**：
```http
HTTP/1.1 200 OK
Content-Type: text/html;charset=utf-8
Transfer-Encoding: chunked

西安交通大学（简称"西安交大"）是国家教育部直属重点大学...
```

**响应特点**：
- 流式响应（chunked编码）
- 文本格式，支持中文
- 实时返回，无需等待完整响应

**业务逻辑**：
```
1. 接收memoryId和message
   ↓
2. 从Redis加载会话历史
   ↓
3. 从向量数据库检索相关知识（Top 3，相似度>0.5）
   ↓
4. 构建Prompt:
   - System: system.txt内容
   - Context: 检索到的知识
   - History: 会话历史
   - User: 当前消息
   ↓
5. 调用通义千问流式API
   ↓
6. 逐块返回给前端
   ↓
7. 完成后更新Redis会话记忆
```

#### 8.2.2 兴趣测试接口

**请求**：
```http
GET /interest-test?memoryId=user_1728300000001_def456&message=开始兴趣测试 HTTP/1.1
Accept: text/html;charset=utf-8
```

**参数**：
| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| memoryId | String | 是 | 会话ID |
| message | String | 是 | 用户回答 |

**响应**：
```http
HTTP/1.1 200 OK
Content-Type: text/html;charset=utf-8
Transfer-Encoding: chunked

你好！欢迎参加AI兴趣测试。接下来我会通过大约10个问题...
【问题1】你在学校最喜欢的科目是什么？为什么喜欢它？
```

**业务逻辑**：
- 使用system_interest_test.txt作为系统提示
- AI主导对话流程，逐步提问
- 10个问题后自动生成报告
- 报告包含性格分析、专业推荐、学习建议等

---

## 9. 数据流程

### 9.1 智能问答流程图

```
┌─────────────────────────────────────────────────────────────┐
│ 用户输入问题：介绍一下西安交通大学                            │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 前端：生成/使用memoryId                                       │
│ memoryId = "user_1728300000000_abc123"                      │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 发送GET请求：/chat?memoryId=xxx&message=xxx                  │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 后端ChatController接收请求                                   │
│ chatController.chat(memoryId, message)                      │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ ChatMemoryProvider加载会话历史                               │
│ Redis GET user_1728300000000_abc123                         │
│ → [历史消息1, 历史消息2, ...]                                │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ ContentRetriever检索相关知识                                 │
│ 1. 将"介绍一下西安交通大学"向量化                            │
│ 2. 在Redis向量库中搜索相似文档                               │
│ 3. 返回Top 3最相关的文本块（相似度>0.5）                     │
│ → [西安交大简介, 历史沿革, 学科优势]                         │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 构建完整Prompt                                               │
│ ┌─────────────────────────────────────────────────────────┐ │
│ │ System: 你是传智教育的AI志愿填报顾问...                  │ │
│ │ Context: [检索到的知识]                                  │ │
│ │ History: [会话历史]                                      │ │
│ │ User: 介绍一下西安交通大学                               │ │
│ └─────────────────────────────────────────────────────────┘ │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 调用通义千问流式API                                          │
│ POST https://dashscope.aliyuncs.com/.../chat/completions    │
│ stream=true                                                 │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 逐块返回响应（SSE）                                          │
│ chunk1: "西安"                                               │
│ chunk2: "交通"                                               │
│ chunk3: "大学"                                               │
│ ...                                                         │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 前端实时显示                                                 │
│ - 累加chunk到消息内容                                        │
│ - 显示打字光标                                               │
│ - 自动滚动到底部                                             │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 对话完成，保存到Redis                                        │
│ Redis SET user_1728300000000_abc123                         │
│ Value: [历史+当前对话]                                       │
│ TTL: 86400秒                                                │
└─────────────────────────────────────────────────────────────┘
```

### 9.2 志愿推荐流程

```
1. 用户填写表单
   ↓
2. 前端验证（姓名、分数、省份等）
   ↓
3. 构建推荐消息
   "我是一名来自河南的考生，高考成绩600分..."
   ↓
4. 生成新memoryId（避免与问答混淆）
   ↓
5. 调用/chat接口
   ↓
6. AI根据分数、意向、地域推荐
   - 冲：620-630分院校
   - 稳：590-610分院校
   - 保：570-590分院校
   ↓
7. 流式返回推荐方案
   ↓
8. 前端展示在结果区域
```

### 9.3 兴趣测试流程

```
1. 用户点击"开始兴趣测试"
   ↓
2. 前端发送: message="开始兴趣测试"
   ↓
3. AI欢迎并提出第1个问题
   【问题1】你在学校最喜欢的科目是什么？
   ↓
4. 用户回答
   ↓
5. AI分析并提出第2个问题
   【问题2】你向往什么类型的工作？
   ↓
6. 循环10次
   ↓
7. AI生成详细报告
   - 综合特质画像
   - 专业推荐（强烈推荐/适合考虑/可以尝试）
   - 学习发展建议
   - 志愿填报建议
   ↓
8. 前端展示完整报告
```

---

## 10. 核心技术实现

### 10.1 RAG（检索增强生成）

**技术原理**：
```
RAG = Retrieval（检索） + Augmented（增强） + Generation（生成）

传统LLM：
用户问题 → LLM → 回答
问题：可能编造信息、知识过时

RAG-LLM：
用户问题 → 向量检索 → 获取相关知识 → 拼接Prompt → LLM → 准确回答
优势：基于真实数据、可追溯来源
```

**实现步骤**：

1. **知识准备**（离线）：
```java
// 1. 加载PDF文档
List<Document> documents = ClassPathDocumentLoader
    .loadDocuments("content", new ApachePdfBoxDocumentParser());

// 2. 文档分块
DocumentSplitter splitter = DocumentSplitters.recursive(500, 100);
// 500字/块，100字重叠（避免语义断裂）

// 3. 向量化
EmbeddingModel embeddingModel // text-embedding-v3

// 4. 存储到向量数据库
redisEmbeddingStore.add(embedding, text, metadata)
```

2. **查询检索**（在线）：
```java
// 1. 用户问题向量化
Embedding questionEmbedding = embeddingModel.embed("介绍一下西安交通大学")

// 2. 向量相似度搜索
List<EmbeddingMatch> matches = embeddingStore.findRelevant(
    questionEmbedding, 
    maxResults=3, 
    minScore=0.5
)

// 3. 返回Top 3文本块
```

3. **增强生成**：
```
Prompt模板：
System: 你是志愿填报顾问
Context: [检索到的知识]
  - 西安交通大学简介...
  - 西安交大是C9联盟成员...
  - 学校有28个学院...
History: [对话历史]
User: 介绍一下西安交通大学
```

**优势**：
- 答案基于真实文档，准确可靠
- 避免AI编造（幻觉问题）
- 知识可更新（替换PDF即可）

### 10.2 流式响应（Streaming）

**为什么需要流式响应？**
- AI生成需要时间（几秒到几十秒）
- 一次性返回用户等待焦虑
- 流式返回模拟打字，体验更好

**技术实现**：

**后端（Spring WebFlux + Reactor）**：
```java
// 返回Flux<String>流
public Flux<String> chat(String memoryId, String message) {
    // LangChain4j自动处理流式响应
    return consultantService.chat(memoryId, message);
}
```

LangChain4j底层：
```java
StreamingChatModel.chat(messages, new StreamingResponseHandler() {
    @Override
    public void onNext(String token) {
        // 每收到一个token，立即发送给前端
        flux.next(token);
    }
    
    @Override
    public void onComplete(Response<AiMessage> response) {
        flux.complete();
    }
});
```

**前端（Fetch + ReadableStream）**：
```javascript
const response = await fetch('/api/chat?...')
const reader = response.body.getReader()
const decoder = new TextDecoder('utf-8')

while (true) {
  const { done, value } = await reader.read()
  if (done) break
  
  const chunk = decoder.decode(value, { stream: true })
  // 逐字符显示，打字机效果
  for (let char of chunk) {
    displayChar(char)
    await delay(calculateDelay(char))
  }
}
```

**打字机效果优化**：
```javascript
function calculateDelay(char) {
  if (/[\u4e00-\u9fa5]/.test(char)) return 40   // 中文
  if (/[。！？]/.test(char)) return 100          // 句号停顿
  if (/[，,]/.test(char)) return 60             // 逗号
  return 30                                     // 默认
}
```

### 10.3 会话记忆（Chat Memory）

**多轮对话的挑战**：
```
用户：介绍一下西安交通大学
AI：西安交通大学是C9联盟成员...

用户：它的录取分数是多少？
AI：？（不知道"它"指什么）
```

**解决方案：会话记忆**

**存储结构**：
```javascript
memoryId: "user_1728300000000_abc123"
messages: [
  { role: "USER", content: "介绍一下西安交通大学" },
  { role: "AI", content: "西安交通大学是..." },
  { role: "USER", content: "它的录取分数是多少？" },
  { role: "AI", content: "西安交大在河南理科..." }
]
```

**自动上下文拼接**：
```java
// LangChain4j自动处理
ChatMemoryProvider provider = memoryId -> 
    MessageWindowChatMemory.builder()
        .id(memoryId)
        .maxMessages(20)      // 保留最近20条
        .chatMemoryStore(redis)
        .build();

// 每次调用AI时自动加载历史
List<ChatMessage> history = memory.messages(memoryId);
// history + newMessage → LLM
```

**滑动窗口策略**：
```
maxMessages = 20
当超过20条时，删除最早的消息
保持上下文大小可控，避免token超限
```

### 10.4 向量数据库（Vector Database）

**为什么需要向量数据库？**
- 传统数据库：精确匹配（WHERE name = '西安交通大学'）
- 向量数据库：语义相似（"西安交大" ≈ "西安交通大学" ≈ "西交"）

**向量化过程**：
```
文本 → Embedding Model → 向量（1536维浮点数数组）

"西安交通大学" → [0.12, -0.34, 0.56, ..., 0.78]
```

**相似度计算**：
```
余弦相似度：
similarity(A, B) = (A · B) / (||A|| * ||B||)

值域：[-1, 1]
- 1: 完全相同
- 0: 无关
- -1: 完全相反
```

**Redis向量索引**：
```bash
# 创建索引（RediSearch）
FT.CREATE idx:embeddings 
  ON HASH 
  PREFIX 1 "langchain4j:embedding:"
  SCHEMA 
    embedding VECTOR HNSW 6 
      TYPE FLOAT32 
      DIM 1536 
      DISTANCE_METRIC COSINE

# 向量搜索
FT.SEARCH idx:embeddings 
  "*=>[KNN 3 @embedding $query_vector]"
  PARAMS 2 query_vector <向量字节>
  RETURN 3 id text score
```

**HNSW算法**：
- Hierarchical Navigable Small World
- 近似最近邻搜索
- 时间复杂度：O(log N)
- 召回率：>95%

### 10.5 系统提示词（System Prompt）

**system.txt**（志愿咨询）：
```
你是传智教育提供的专业的AI志愿填报顾问，可以给用户提供如下功能：
1. 查询目标院校的院校简介
2. 查询目标院校的录取规则
3. 查询目标院校的奖学金设置状况
...
9. 根据学生提供的分数推荐学校和专业，按照冲、稳、保逻辑
10. 高考志愿填报一对一沟通预约服务

说明：
1. 每次回答完问题，加上：建议您预约一个一对一的指导服务
2. 下预约单需要用户提供：姓名、性别、电话、时间、省份、分数
3. 预约成功后提示：恭喜预约成功，我们会准时联系您
4. 不要提及"根据您提供的信息"这样的话术
```

**设计原则**：
- **角色定位**：AI志愿填报顾问
- **能力边界**：只回答志愿填报相关问题
- **行为规范**：话术要求、预约流程
- **用户体验**：引导但不强制，委婉提示

**system_interest_test.txt**（兴趣测试）：
```
你是专业AI职业兴趣测试顾问
测试流程：10个问题，4个维度
1. 学科兴趣（2-3问）
2. 职业兴趣（2-3问）
3. 性格特点（2-3问）
4. 价值观（2-3问）

问答规则：
- 每次只问1个问题
- 根据回答灵活调整
- 用轻松友好的语气
- 适时鼓励

【生成推荐报告】
完成后必须立即生成报告（至少2000字）：
1. 综合特质画像
2. 专业推荐（强烈推荐/适合/可尝试）
3. 学习发展建议
4. 志愿填报建议
```

**提示词工程技巧**：
- **少样本学习（Few-shot）**：提供示例
- **思维链（CoT）**：引导逐步推理
- **角色扮演**：定义AI身份
- **输出格式**：明确结构要求

---

## 11. 安全设计

### 11.1 API密钥保护

**问题**：
- API Key泄露会导致账户盗用
- 代码可能提交到公开仓库

**解决方案**：
```yaml
# application.yaml
langchain4j:
  open-ai:
    api-key: ${API-KEY}  # 环境变量
```

**部署时注入**：
```bash
# Linux/Mac
export API_KEY=sk-xxx
java -jar app.jar

# Docker
docker run -e API_KEY=sk-xxx app:latest

# Kubernetes
apiVersion: v1
kind: Secret
metadata:
  name: api-secret
data:
  api-key: c2stxxx=  # base64编码
```

### 11.2 跨域安全（CORS）

**CorsConfig.java**：
```java
@Configuration
public class CorsConfig implements WebMvcConfigurer {
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
            .allowedOrigins("http://localhost:5173")  // 开发环境
            .allowedMethods("GET", "POST", "PUT", "DELETE")
            .allowedHeaders("*")
            .allowCredentials(true);
    }
}
```

**生产环境**：
```java
.allowedOrigins("https://yourdomain.com")  // 仅允许生产域名
```

### 11.3 输入验证

**前端验证**：
```javascript
const rules = {
  score: [
    { type: 'number', min: 0, max: 750, message: '分数范围0-750' }
  ]
}
```

**后端验证**（建议添加）：
```java
@RestController
public class ChatController {
    @RequestMapping("/chat")
    public Flux<String> chat(
        @RequestParam @NotBlank String memoryId,
        @RequestParam @NotBlank @Size(max=500) String message
    ) {
        // 验证memoryId格式
        if (!memoryId.matches("^user_\\d+_[a-z0-9]+$")) {
            throw new IllegalArgumentException("Invalid memoryId");
        }
        // 敏感词过滤
        message = sensitiveWordFilter.filter(message);
        
        return consultantService.chat(memoryId, message);
    }
}
```

### 11.4 数据脱敏

**会话记忆脱敏**：
- 姓名：张** → 张某某
- 电话：138****1234
- 身份证：前6后4中间*

**日志脱敏**：
```java
logging:
  pattern:
    console: "%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"
  level:
    dev.langchain4j: info  # 生产环境关闭debug
```

### 11.5 频率限制

**Redis + Lua实现限流**：
```java
@Component
public class RateLimiter {
    public boolean allowRequest(String memoryId) {
        String key = "rate_limit:" + memoryId;
        // 每分钟最多10次请求
        Long count = redis.incr(key);
        if (count == 1) {
            redis.expire(key, 60);
        }
        return count <= 10;
    }
}
```

---

## 12. 性能优化

### 12.1 Redis优化

**连接池配置**：
```yaml
spring:
  data:
    redis:
      lettuce:
        pool:
          max-active: 20
          max-idle: 10
          min-idle: 5
          max-wait: 1000ms
```

**持久化策略**：
```bash
# redis.conf
save 900 1        # 15分钟内至少1次写入
save 300 10       # 5分钟内至少10次写入
save 60 10000     # 1分钟内至少10000次写入

appendonly yes    # 开启AOF持久化
```

### 12.2 向量检索优化

**索引参数调优**：
```
HNSW参数：
- M: 16（每层连接数，越大越准确但越慢）
- EF_CONSTRUCTION: 200（构建时搜索宽度）
- EF_RUNTIME: 10（查询时搜索宽度）
```

**分块策略**：
```java
DocumentSplitters.recursive(500, 100)
// 500字/块：平衡检索精度和速度
// 100字重叠：避免语义断裂
```

### 12.3 前端性能

**代码分割**：
```javascript
// 路由懒加载
component: () => import('../views/ChatView.vue')
```

**打包优化**：
```javascript
// vite.config.js
build: {
  rollupOptions: {
    output: {
      manualChunks: {
        'element-plus': ['element-plus'],
        'vue-vendor': ['vue', 'vue-router', 'pinia']
      }
    }
  }
}
```

**CDN加速**：
```html
<!-- index.html -->
<link rel="preconnect" href="https://cdn.jsdelivr.net">
```

### 12.4 流式优化

**分块大小**：
```java
// LangChain4j默认按token分块
// 通义千问每次返回1-5个token
// 权衡：块越小越流畅，但请求次数越多
```

**前端防抖**：
```javascript
// 避免频繁更新DOM
const updateMessage = debounce((content) => {
  message.value = content
}, 16)  // 60fps
```

---

## 13. 部署架构

### 13.1 开发环境

```
┌──────────────┐    ┌──────────────┐    ┌──────────────┐
│              │    │              │    │              │
│   Frontend   │───▶│   Backend    │───▶│    Redis     │
│ localhost:   │    │ localhost:   │    │ localhost:   │
│    5173      │    │    8080      │    │    6379      │
│              │    │              │    │              │
│  npm run dev │    │ mvn spring-  │    │ redis-server │
│              │    │  boot:run    │    │              │
└──────────────┘    └──────────────┘    └──────────────┘
       │                    │
       │                    ▼
       │            ┌──────────────┐
       │            │   通义千问    │
       │            │ dashscope.   │
       │            │ aliyuncs.com │
       └───────────▶└──────────────┘
          /api代理
```

### 13.2 生产环境

```
                    ┌─────────────────────────────┐
                    │       Nginx (反向代理)       │
                    │   https://yourdomain.com    │
                    └───────────┬─────────────────┘
                                │
                ┌───────────────┴───────────────┐
                │                               │
                ▼                               ▼
    ┌────────────────────┐          ┌────────────────────┐
    │   Frontend (静态)   │          │   Backend (JAR)    │
    │  /usr/share/nginx/ │          │  java -jar app.jar │
    │   html/dist/       │          │   :8080            │
    └────────────────────┘          └──────────┬─────────┘
                                               │
                                               ▼
                                    ┌────────────────────┐
                                    │   Redis (Docker)   │
                                    │   redis:7-alpine   │
                                    │   :6379            │
                                    └──────────┬─────────┘
                                               │
                                               ▼
                                    ┌────────────────────┐
                                    │    通义千问 API     │
                                    └────────────────────┘
```

### 13.3 Nginx配置

```nginx
server {
    listen 80;
    server_name yourdomain.com;

    # 前端静态文件
    location / {
        root /usr/share/nginx/html/dist;
        try_files $uri $uri/ /index.html;
    }

    # 后端API代理
    location /api/ {
        proxy_pass http://localhost:8080/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        
        # 流式响应支持
        proxy_buffering off;
        proxy_cache off;
        proxy_set_header Connection '';
        proxy_http_version 1.1;
        chunked_transfer_encoding on;
    }
}
```

### 13.4 Docker部署

**Dockerfile（后端）**：
```dockerfile
FROM openjdk:17-jdk-alpine
WORKDIR /app
COPY target/consultant-0.0.1-SNAPSHOT.jar app.jar
EXPOSE 8080
ENV API_KEY=your-api-key
ENTRYPOINT ["java", "-jar", "app.jar"]
```

**docker-compose.yml**：
```yaml
version: '3.8'
services:
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data
    command: redis-server --appendonly yes

  backend:
    build: ./Backend
    ports:
      - "8080:8080"
    environment:
      - API_KEY=${API_KEY}
    depends_on:
      - redis

  frontend:
    build: ./Front/Consultant
    ports:
      - "80:80"
    depends_on:
      - backend

volumes:
  redis-data:
```

**启动命令**：
```bash
docker-compose up -d
```

---

## 14. 开发规范

### 14.1 代码规范

**Java**：
- 遵循阿里巴巴Java开发手册
- 类名：大驼峰（ConsultantService）
- 方法名：小驼峰（chatStream）
- 常量：全大写下划线（MAX_MESSAGES）

**JavaScript**：
- ESLint + Vue官方规范
- 组件名：大驼峰（ChatView.vue）
- 变量名：小驼峰（memoryId）
- 使用Composition API

### 14.2 Git规范

**分支策略**：
```
main          # 生产分支
  ├─ develop  # 开发分支
      ├─ feature/chat-module      # 功能分支
      ├─ feature/recommend-module
      └─ bugfix/fix-stream-error  # 修复分支
```

**提交规范**：
```
feat: 新增兴趣测试模块
fix: 修复流式响应乱码问题
docs: 更新README部署说明
style: 优化ChatView样式
refactor: 重构向量检索逻辑
test: 添加单元测试
chore: 升级依赖版本
```

### 14.3 文档规范

**注释**：
```java
/**
 * 智能志愿填报咨询服务
 * 
 * @author 开发者姓名
 * @since 2025-10-07
 */
public interface ConsultantService {
    /**
     * 流式对话方法
     * 
     * @param memoryId 会话ID，用于上下文记忆
     * @param message 用户消息
     * @return 流式响应
     */
    Flux<String> chat(String memoryId, String message);
}
```

**README**：
- 项目介绍
- 快速启动
- 配置说明
- API文档
- 常见问题

---

## 15. 未来扩展

### 15.1 功能扩展

**1. 预约系统完善**
- 真实预约表单
- 数据库存储预约信息
- 导师管理后台
- 短信/邮件提醒

**2. 用户系统**
- 用户注册/登录
- 个人中心
- 收藏志愿方案
- 历史记录

**3. 数据分析**
- 录取概率预测
- 专业就业数据
- 薪资趋势分析
- 可视化大屏

**4. 移动端**
- 微信小程序
- APP开发（Flutter）
- 响应式H5

### 15.2 技术优化

**1. 多模型支持**
```java
@AiService
public interface ConsultantService {
    // 支持切换模型
    @Model("gpt-4")
    Flux<String> chatGPT4(String memoryId, String message);
    
    @Model("qwen-max")
    Flux<String> chatQwenMax(String memoryId, String message);
}
```

**2. 缓存优化**
```java
@Cacheable(value = "school_info", key = "#schoolName")
public String getSchoolInfo(String schoolName) {
    // 高频查询结果缓存
}
```

**3. 多语言支持**
- i18n国际化
- 支持英文界面
- 港澳台繁体

### 15.3 数据扩展

**1. 知识库扩充**
- 全国2000+所高校
- 详细专业介绍
- 就业数据
- 校园环境图片

**2. 数据源**
- 对接教育部阳光高考平台API
- 爬取各高校官网
- 第三方数据采购

### 15.4 AI能力提升

**1. 多模态AI**
- 图片识别（成绩单OCR）
- 语音对话
- 视频讲解

**2. Agent架构**
```
用户问题
   ↓
ReAct Agent（推理+行动）
   ├─ 工具1: 查询数据库
   ├─ 工具2: 计算录取概率
   ├─ 工具3: 生成可视化图表
   └─ 工具4: 发送预约短信
   ↓
综合结果返回
```

**3. 微调模型**
- 基于志愿填报领域数据微调
- 提升专业性和准确性

---

## 16. 总结

### 16.1 技术亮点

1. **AI大模型应用**
   - 基于通义千问，自然语言理解能力强
   - RAG技术，保证答案准确性

2. **流式响应**
   - WebFlux + Reactor响应式编程
   - 打字机效果，用户体验优秀

3. **会话记忆**
   - Redis持久化存储
   - 支持多轮上下文对话

4. **向量检索**
   - 语义相似度搜索
   - 快速定位相关知识

5. **现代化前端**
   - Vue 3 Composition API
   - Element Plus组件库
   - 响应式设计

### 16.2 业务价值

- **考生**：科学填报志愿，降低滑档风险
- **家长**：节省咨询成本，获得专业建议
- **教育机构**：提升服务效率，扩大服务规模
- **社会**：教育资源优化配置

### 16.3 可复用性

本系统架构可应用于其他领域：
- **医疗咨询**：替换知识库为医学资料
- **法律咨询**：法律法规 + 案例库
- **金融咨询**：理财知识 + 产品介绍
- **技术客服**：产品手册 + 常见问题

---

**文档结束**

本文档详细阐述了智能高考志愿填报系统的架构设计、技术实现和业务逻辑。
如有疑问，请联系开发团队。

**维护者**: 传智教育开发团队  
**更新日期**: 2025年10月7日  
**版本**: v1.0.0

